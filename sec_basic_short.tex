We consider a directed graph $G=(V,E)$, where each edge $e\in E$ has an associated \emph{length} $\ell(e)\in\N_+$, and \emph{cost} $c(e)\in\N_+\crl{0}$.
For each node $v$, we denote its degree $\Delta(v)$ as the sum of the in-degree and out-degree, and define the \emph{maximum degree} $\Delta \defeq \max_v\Delta(v)$.
For any source-terminal pair $s,t\in V$, we denote by $\Pst$ the set of all simple $(s,t)$-paths (without loops or cycles). 
Throughout this work, we only consider simple paths, which we refer to as paths.

For any path $P$, we define its length $\ell(P)$ and cost $c(P)$ as the sum of edge lengths and edge costs in $P$. 
Note that any path $P$ with more than one node has length at least $1$ (since we assume lengths are integers).
For $s,t\in V$, the distance from $s$ to $t$, denoted $\dist(s,t)$, is the smallest length among all paths $P\in\Pst$.
For a node $v$ to a path $P$, we abuse notation to denote $\dist(v,P)$ as the minimum distance from $v$ to any node $w\in P$; the distance $\dist(P,v)$ from $P$ to $v$ is defined analogously.
Note that  $\dist(P,v)$ and  $\dist(v,P)$ need not be the same as the graph is directed.
We denote the shortest $(s,t)$-path (if it exists) as $P(s,t)$, and denote the set of all shortest paths in $G$ as $\PS$.
Finally, we define $D\defeq\max_{P\in\PS}\ell(P)$ to be the diameter of $G$.

Our goal is to develop a data-structure to answer \emph{Constrained Shortest-Path} (CSP) queries: 
Given a source-terminal pair $s,t$ and a budget $b$, we want to return a path $P$ solving
$\min_{P \in \Pst} \ell(P)$
subject to $c(P) \leq b$.
We define $\dist(s,t|b)$ to be the minimum of this problem.
If there is no feasible solution, we define $\dist(s,t|b)=\infty$.
Note that the CSP problem may have multiple solutions as there could be several paths with the same length and cost lower than $b$.
To limit these solutions to those with minimal cost, we require that the path also be \emph{efficient}. 
\begin{definition}[Efficient Path]
\label[definition]{def:effpath}
A path $P\in \Pst$ is called \emph{efficient} if there is no other path $P'\in \Pst$ such that $\ell(P')\leq \ell(P)$ and $c(P')\leq c(P)$ with at least one inequality strict.
\end{definition}
We denote the set of all efficient paths as $\PE$, and define the \emph{Pareto frontier} from $s$ to $t$ as $\Pst\cap\PE$.
Observe that every subpath of an efficient path is also efficient (if not, we could improve the path by replacing the subpath).
For $r>0$ and $v\in V$, we define the \emph{forward and reverse balls of radius $r$} by $\Bf_r(v)\defeq\{u\in V: \dist(v,u)\leq r\}$ and $\Bb_r(v)\defeq\{u\in V: \dist(u,v)\leq r\}$, and also define $B_r(v)\defeq\Bf_r(v)\cup\Bb_r(v)$.
Finally, a graph $G$ is said to have a \emph{doubling dimension} $\alpha$ if, for any node $v$ and any $r>0$, the ball $B_{2r}(v)$ can be covered by at most $\alpha$ balls of radius $r$.


\paragraph{Hitting Sets and the Highway Dimension}
\label{ssec:hddef}
To parametrize the performance of our CSP algorithms, we use the notion of the \emph{highway dimension}, introduced by \citet{highway2013,highway2010} to parametrize SP computations in undirected graphs. 
Our treatment here generalizes the notions in \citep{highway2013} (which deals only with undirected graphs and shortest paths) to cover directed graphs and general sets of paths.
These generalizations are not trivial, but due to lack of space, we defer technical details to \cite{TechReport}. 


We say that a set $C\subseteq V$ \emph{hits} any given path $Q$ if some node in $Q$ belongs to $C$. Now, for any \emph{path system} $\calQ$ (i.e., any collection of paths), we say that $C$ is a \emph{hitting set for a path system} $\calQ$ if it hits every $Q\in\calQ$. 
For any $r>0$, we say a path $Q$ is $r$-significant if $\ell(Q)>r$. 
For a given path system $\calQ$, we denote $\calQ_r$ as the set of all $r$-significant paths in $\calQ$.
Hitting sets are useful for compressing path systems. 
In particular, even if the hitting set is large, the extent to which a path system can be compressed depends on the \emph{local sparsity} of hitting sets with respect to \emph{significant paths} of $\calQ$.

\begin{definition}[Locally-Sparse Hitting Sets]\label[definition]{def:lshs}
	Given a path system $\calQ$ and $r>0$, an $(h,r)$ locally-sparse hitting set (or $(h,r)$-LSHS) is a set $C\subseteq V$ with two properties: 
	\begin{enumerate}[nosep]
		\item Hitting: $C$ is a hitting set for $\calQ_r$.
		\item Local sparsity: for every $v\in V$, $\abs*{B_{2r}(v)\cap C}\leq h$.
	\end{enumerate}
\end{definition}


As we describe below, having access to an $(h,r)$-LSHS enables the compression of path system $\calQ$ via the construction of \emph{hub labels}; however, we it is not obvious how to efficiently compute such an object. 
The \emph{highway dimension} is a property that guarantees both existence and efficient computation of LSHS; to do so, it essentially re-orders the sequence of qualifiers in the definition of $(h,r)$-LSHS, requiring the existence of a small hitting set for each individual neighborhood, rather than a single hitting set which is locally sparse. .
%it was shown that the \emph{highway dimension} is a property that ensures both existence and efficient computation of LSHS \cite{highway2013}. 
To define the highway dimension (HD), we first need two additional definitions:
for $v\in V, r>0$, we define the \emph{forward path-neighbourhoods} with respect to any given path system $\calQ$ as $
S_r^+(v,\calQ) \defeq\crl*{Q\in\calQ_r: \dist(v,Q)\leq 2r}$ (and similarly, the reverse path-neighbourhood as $S_r^-(v,\calQ) \defeq\crl*{Q\in\calQ_r: \dist(Q,v)\leq 2r}$); we also define $S_r(v,\calQ) \defeq S_r^+(v,\calQ)\cup S_r^-(v,\calQ)$. Now we have:
%Now we can define the HD of a path system $\calQ$. 
%Essentially, the HD re-orders the sequence of qualifiers in the definition of $(h,r)$-LSHS: it requires the existence of a small hitting set for each individual neighborhood, rather than a single hitting set which is locally sparse. 
\begin{definition}[Highway Dimension]	\label[definition]{def:hddef}
	A path system $\calQ$ has HD $h$ if, $\forall r>0,v\in V$, there exists a set $H_{v,r}\subseteq V$ such that $\card{H_{v,r}}\leq h$ and $H_{v,r}$ is a hitting set for $S_r(v,\calQ)$.
\end{definition}

As shorthand, we refer to the HD of $(G,\ell)$ as that of $\PS$. 
Note that $HD\leq h$ is a more stringent requirement than the existence of an $(h,r)$-LSHS $C$, since $C\cap B_{2r}(v)$ need not hit all the paths in $S_r(v,\calQ)$. 
However, if $G$ has $HD \leq h$, then this guarantees the existence of a $(h,r)$-LSHS:
\begin{proposition}\label{prop:equiv}
	If the path system $\calQ$ has HD $h$, then, $\forall\,r>0$, there exists an $(h,r)$-LSHS.
\end{proposition}

This fact follows by adapting the proof from \cite[Theorem 4.2]{highway2013} to our general case, for details see \cite{TechReport}.
Moreover, though this result does not touch on computability, we discuss in \cref{ssec:aug} how if $G$ has $HD \leq h$, then this permits efficient computation of LSHS.
%In particular, for any $r$, a simple greedy algorithm gives an $(\Or(h\log n),r)$-LSHS, and a more complex algorithm (which is still poly-time) gives an $(\Or(h\Delta\log h\Delta),r)$-LSHS. 


\paragraph{Shortest-Paths via Hub Labels}
\label{ssec:hldef}
Two of the most successful data-structures enabling fast shortest path queries at scale are \emph{contraction hierarchies} (CH)~\cite{geisberger_ch_definition} and \emph{hub labels} (HL)~\cite{cohen_definition_hl}.
These are general techniques which always guarantee correct SP computation, but have no uniform storage/query-time bounds for all graphs. 
In this work, we focus only on HL; for analogous results for CH see \cite{TechReport}. % Appendix~\ref{sec:ch}.

The basic HL technique for SP computations is as follows:
Every node $v$ is associated with a hub label $L(v) = \crl*{\Lf(v),\Lb(v)}$, comprising of a set of forward hubs $\Lf(v)$ and reverse hubs $\Lb(v)$.
We also store $\dist(v,w) \,\forall\, w\in\Lf(v)$ and $\dist(u,v)\,\forall\,u\in\Lb(v)$.
The hub labels are said to satisfy the \emph{cover property} if, for any $s\neq t\in V$, $\Lf(s)\cap\Lb(t)$ contains at least one node in $P(s,t)$.
In the case that $t$ is not reachable from $s$, it must be that $\Lf(s)\cap\Lb(t)=\varnothing$.

With the aid of the cover property, we can obtain $\dist(s,t)$ by searching for the minimum value of $\dist(s,w)+\dist(w,t)$ over all nodes $w\in\Lf(s)\cap\Lb(t)$.
If the hubs are sorted by ID, this can be done in time $\Or(\card{\Lf(s)}+\card{\Lb(t)})$ via a single sweep.
Moreover, by storing the second node in $P(s,w)$ for each $w\in \Lf(s)$, and the penultimate node in $P(w,t)$ for each $w\in \Lb(t)$, we can also recover the shortest path recursively, as each HL query returns at least one new node $w\in P(s,t)$.
%Note that we need to store this extra information, otherwise we could have $\Lf(s)\cap\Lb(t)=\crl{s}$.
Let $\Lm \defeq \max_v\abs*{\Lf(v)}+\max_v\abs*{\Lb(v)}$ be the size of the maximum HL.
Then the per-node storage requirement is $\Or(\Lm)$, while the query time is $\Or(\Lm\ell(P(s,t)))$.

Although hub labels always exist (in particular, we can always choose $\Lf(s)$ to be the set of nodes reachable from $v$, and $\Lb(s)$ the set of nodes that can reach $v$), finding \emph{optimal} hub-labels (in terms of storage/query-time bounds) is known to be NP-hard~\cite{babenko_hl_complexity}.
The highway dimension and the notion of an $(h,r)$-LSHS allow us to construct hub labels with guarantees on preprocessing time and $\Lm$. For this, we need the additional notion of a \emph{multi-scale LSHS}, a collection of sets $\crl*{C_i: i=1,\ldots,\log D}$, such that each $C_i$ is an $(h,2^{i-1})$-LSHS.
Given such a collection, we can now obtain small hub labels: we outline this construction for directed graphs, closely following the undirected graph construction in \cite[Theorem 5.1]{highway2013}.
\begin{proposition}
\label[proposition]{theo:construct_hl}
For graph $(G,\ell)$, given a multi-scale LSHS collection $\crl*{C_i:i=0,\ldots,\log D}$, where each $C_i$ is an $(h,2^{i-1})$-LSHS, we can construct hub labels of size at most $h(1+\log D)$.
\end{proposition}
\begin{proof}
	For each node $v$, we define the hub label $L(v)$ as
	\[
	\Lf(v)\defeq  \bigcup_{i=0}^{\log D}C_i\cap \Bf_{2^i}(v) \quad\text{ and }\quad
	\Lb(v)\defeq \bigcup_{i=0}^{\log D}C_i\cap \Bb_{2^i}(v).
	\]
	Since each $C_i$ is an $(h,2^{i-1})$-LSHS which we intersect with balls of radius $2\cdot 2^{i-1}$, every set in the union contributes at most $h$ elements and the maximum size is as claimed.
	To prove the cover property, we note that, if $t$ is not reachable from $s$, by definition $\Lf(s)\cap\Lb(t)=\varnothing$.
	This is because the elements in $\Lf(s)$ are reachable from $s$ and the elements in $\Lb(t)$ reach $t$.
	On the other hand, when $P(s,t)$ exists, let $i$ be such that $2^{i-1}<\ell(P(s,t))\leq 2^i$.
	Now any point in the path belongs to both $\Bf_{2^i}(s)$ and $\Bb_{2^i}(t)$, and hence $C_i\cap P(s,t)$ is in both hubs (which is not empty since $C_i$ hits all SP of length $\geq 2^{i-1}$).
\end{proof}



%As we mentioned before, a greedy algorithm returns a $\Or(h\log n)$ approximation to any $(h,r)$-LSHS, however, if the HD $\leq h$, this can be improved to obtain a $\Or(h\Delta\log(h\Delta))$ approximation.
%This argument, which extends Corollary 7.3 in \cite{highway2013}, is presented in Section~\ref{sec:preproc}.
In \cref{ssec:aug} we show how to compute the desired multi-scale LSHS in polynomial time. In particular, if graph $G$ has HD $h$, then in polynomial time we can obtain multi-scale LSHS with sparsity $h'=\Or(h\Delta\log(h\Delta))$ (i.e., the HL have size $h'(1+\log D)$ instead of $h(1+\log D)$).
A more subtle point is that the theoretical algorithm, even though polynomial, is impractical for large networks.
In \cref{sec:numeric}, we discuss heuristics that work better in practice.
